/**
 * @module @envguard/cli/commands
 * @file export.action.ts
 * @description Export secrets to .env file (insecure)
 */

import fs from 'fs/promises';
import path from 'path';
import { SystemKeychain } from '@envguard/core';
import { ConfigManager } from '@envguard/core';
import { ManifestManager } from '@envguard/core';
import { error, success, verbose, warn, info, LogTag } from '../utils/logger';

export interface ExportOptions {
  verbose?: boolean;
  unsafe?: boolean;
  to?: string;
  env?: string;
}

export async function exportAction(options: ExportOptions): Promise<void> {
  const configManager = new ConfigManager();
  const manifestManager = new ManifestManager();

  verbose(options.verbose === true, LogTag.LOG, 'options:', options);

  // Check if EnvGuard is initialized
  const config = await configManager.load();
  if (!config) {
    error('EnvGuard not initialized. Run "envg init" first.');
    process.exit(1);
  }

  // Require --unsafe flag
  if (!options.unsafe) {
    error('Export requires --unsafe flag');
    info('\nWARNING: Exporting creates INSECURE plaintext files!');
    info('This should only be used for:');
    info('  • Legacy tool compatibility');
    info('  • CI/CD that requires .env files');
    info('  • Temporary debugging');
    info('\nAdd --unsafe to confirm you understand the risks.');
    process.exit(1);
  }

  const packageName = config.getPackage();
  const defaultEnvironment = config.getDefaultEnvironment();
  const environment = options.env || defaultEnvironment;
  const outputFile = options.to || '.env';

  warn('\n⚠️  SECURITY WARNING ⚠️');
  warn('Creating INSECURE plaintext file with secrets!');
  warn(`File: ${outputFile}`);
  warn(`Environment: ${environment}`);
  warn('');

  // Get all keys
  const keychain = new SystemKeychain(
    packageName,
    process.cwd(),
    defaultEnvironment
  );
  const allKeys = await manifestManager.listKeys(packageName);

  const envContent: string[] = [];
  envContent.push(`# Generated by EnvGuard - Environment: ${environment}`);
  envContent.push(`# WARNING: This file contains PLAINTEXT secrets!`);
  envContent.push(`# DO NOT commit to version control`);
  envContent.push('');

  for (const key of allKeys) {
    const value = await keychain.get(key, options.env);
    if (value !== null) {
      envContent.push(`${key}=${value}`);
    }
  }

  // Write file
  await fs.writeFile(
    path.join(process.cwd(), outputFile),
    envContent.join('\n')
  );

  // Ensure .gitignore includes this file
  const gitignorePath = path.join(process.cwd(), '.gitignore');
  try {
    let gitignore = await fs.readFile(gitignorePath, 'utf-8');
    if (!gitignore.includes(outputFile)) {
      gitignore += `\n${outputFile}\n`;
      await fs.writeFile(gitignorePath, gitignore);
      info(`Added ${outputFile} to .gitignore`);
    }
  } catch {
    warn('.gitignore not found - file NOT protected!');
  }

  success(`\nExported ${allKeys.length} secret(s) to ${outputFile}`);
  warn('\nREMEMBER:');
  warn(`  • Delete ${outputFile} when done`);
  warn(`  • Never commit ${outputFile} to git`);
  warn('  • This file contains secrets in PLAINTEXT');
}
